<?php

/**
 * @file
 * Tests for taxonomy_menu.module.
 */

/**
 * Provides common helper methods for Taxonomy Menu module tests.
 */
class TaxonomyMenuWebTestCase extends TaxonomyWebTestCase {

  /**
   * Creates a hierarchy of taxonomy terms for the vocabulary defined in the
   * current class. The hierarchy is as follow:
   *
   * terms[1]         | depth: 0
   * -- terms[2]      | depth: 1
   * -- terms[3]      | depth: 1
   * ---- terms[4]    | depth: 2
   * -- terms[5]      | depth: 1
   * terms[6]         | depth: 0
   * -- terms[7]      | depth: 1
   *
   * @TODO Add multiple parents when taxonomy_menu can deal with it.
   */
  function createTermsHierarchy($vocabulary) {
    $terms = array();

    // Create taxonomy terms.
    for ($i = 1; $i < 8; $i++) {
      $terms[$i] = $this->createTerm($vocabulary);
    }

    // Set the hierarchy.
    $terms[2]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[2]);
    $terms[3]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[3]);
    $terms[4]->parent = array($terms[3]->tid);
    taxonomy_term_save($terms[4]);
    $terms[5]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[5]);
    $terms[7]->parent = array($terms[6]->tid);
    taxonomy_term_save($terms[7]);

    return $terms;
  }

  /**
   * Create a new term record
   */
  function createNewTerm($vocabulary, $name = NULL, $parent = NULL) {
    $term = new stdClass();
    $term->name = ($name === NULL) ? $this->randomName() : $name;
    $term->description = $this->randomName();
    $term->format = db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocabulary->vid;
    if ($parent !== NULL) {
      $term->parent = array($parent->tid);
    }

    return $term;
  }
}

/**
 * Tests the taxonomy vocabulary interface.
 */
class TaxonomyMenuFunctionalTest extends TaxonomyMenuWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Vocabulary interface',
      'description' => 'Test the taxonomy menu vocabulary interface.',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    // Create and login administrative user.
    $admin_user = $this->drupalCreateUser(array('administer taxonomy', 'administer menu'));
    $this->drupalLogin($admin_user);
    // Create a vocabulary.
    $this->vocabulary = $this->createVocabulary();
    // Create a hierarchy of taxonomy terms.
    $this->hierarchy = $this->createTermsHierarchy($this->vocabulary);
  }

  /**
   * Saves a taxonomy vocabulary via the user interface.
   */
  function testTaxonomyMenuVocabularyInterface() {
    $menu_name = 'user-menu';
    $vocab = $this->vocabulary->machine_name;

    // Visit the main taxonomy administration page.
    $this->drupalGet('admin/structure/taxonomy/' . $vocab . '/edit');

    // Options for the taxonomy vocabulary edit form.
    $edit = array();

    // Try to submit a vocabulary when menu location is a root menu item.
    $edit['taxonomy_menu[vocab_parent]'] = $menu_name . ':0';
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been updated.'));

    // Try to submit a vocabulary removing the menu location.
    $edit['taxonomy_menu[vocab_parent]'] = '0';
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been removed.'));

    // Try to submit a vocabulary when menu location is a menu item.
    $edit['taxonomy_menu[vocab_parent]'] = $menu_name . ':2';
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been updated.'));
  }

}

/**
 * Tests for taxonomy vocabulary functions.
 */
class TaxonomyMenuUnitTest extends TaxonomyMenuWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'CRUD functions',
      'description' => 'Test CRUD functions',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    // Create and login administrative user.
    $admin_user = $this->drupalCreateUser(array(
      'access administration pages',
      'administer blocks',
      'administer taxonomy',
      'administer menu',
    ));
    $this->drupalLogin($admin_user);
    // Create a vocabulary.
    $this->vocabulary = $this->createVocabulary();
    // Create a hierarchy of taxonomy terms.
    $this->hierarchy = $this->createTermsHierarchy($this->vocabulary);
  }

  /**
   * Tests CRUD functions.
   */
  function testTaxonomyMenuCRUD() {
    $menu_name = 'main-menu'; // Name of the menu.
    $hierarchy_count = count($this->hierarchy);

    // Set form settings.
    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = $menu_name . ':0';

    // Ensure that the taxonomy vocabulary form is successfully submitted.
    $vocab = $this->vocabulary->machine_name;
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertResponse(200);

    // Terms creation: ensure that the same number of menu links are created
    // from the taxonomy terms of the vocabulary.
    $query = db_select('taxonomy_menu', 'tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=');
    $query->join('menu_links', 'ml', 'ml.mlid = tm.mlid');
    $query
      ->fields('tm')
      ->condition('ml.module', 'taxonomy_menu')
      ->condition('ml.menu_name', $menu_name);
    $row_count = $query->execute()->rowCount();
    $this->assertEqual($hierarchy_count, $row_count);

    // Term update: ensure that the menu link is updated when the taxonomy term is
    // updated.
    $term = $this->hierarchy[3]; // Arbitrary taxonomy term from the hierarchy.
    $new_name = $this->randomName();
    $term->name = $new_name;
    taxonomy_term_save($term);
    $this->drupalGet('admin/structure/menu/manage/' . $menu_name);
    $this->assertLink($new_name);

    // Term deletion: ensure that the menu link is deleted when the taxonomy
    // term is deleted.
    $query = db_select('taxonomy_menu', 'tm')
      ->fields('tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=')
      ->condition('tm.tid', $term->tid, '=');
    $mlid = $query->execute()->fetchField();

    taxonomy_term_delete($term->tid);

    $query = db_select('taxonomy_menu', 'tm')
      ->fields('tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=')
      ->condition('tm.tid', $term->tid, '=');
    $row_count = $query->execute()->rowCount();
    $this->assertEqual(0, $row_count);

    $query = db_select('menu_links', 'ml')
      ->fields('ml')
      ->condition('ml.mlid', $mlid)
      ->condition('ml.module', 'taxonomy_menu')
      ->condition('ml.menu_name', $menu_name);
    $row_count = $query->execute()->rowCount();
    $this->assertEqual(0, $row_count);

    // Vocabulary deletion: ensure that all menu links and all associations in
    // the taxonomy menu table are deleted when a vocabulary is deleted.
    $query = db_select('taxonomy_menu', 'tm')
      ->fields('tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=');
    $mlids = $query->execute()->fetchAllAssoc('mlid');

    taxonomy_vocabulary_delete($this->vocabulary->vid);

    $query = db_select('taxonomy_menu', 'tm')
      ->fields('tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=');
    $row_count = $query->execute()->rowCount();
    $this->assertEqual(0, $row_count);

    $query = db_select('menu_links', 'ml')
    ->fields('ml')
    ->condition('ml.mlid', array_keys($mlids), 'IN')
    ->condition('ml.module', 'taxonomy_menu')
    ->condition('ml.menu_name', $menu_name);
    $row_count = $query->execute()->rowCount();
    $this->assertEqual(0, $row_count);

  }

  /**
   * Tests creation of menu links on a custom menu.
   */
  function testTaxonomyMenuCustomMenu() {
    // Set options for the creation of a custom menu.
    $edit = array();
    $custom_name = $this->randomName(16);
    $machine_name = drupal_substr(hash('sha256', $custom_name), 0, MENU_MAX_MENU_NAME_LENGTH_UI);
    $edit['title'] = $custom_name;
    $edit['menu_name'] = $machine_name;

    // Submit the menu creation form.
    $this->drupalPost('admin/structure/menu/add', $edit, 'Save');
    $this->assertResponse(200);

    // Set options of the vocabulary edit form and submit it.
    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = 'menu-' . $machine_name . ':0';
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');
    $this->assertResponse(200);

    // Check that the menu links were created in the custom menu.
    $query = db_select('taxonomy_menu', 'tm')
      ->condition('tm.vid', $this->vocabulary->vid, '=');
    $query->join('menu_links', 'ml', 'ml.mlid = tm.mlid');
    $query
      ->fields('ml')
      ->condition('ml.module', 'taxonomy_menu')
      ->condition('ml.menu_name', 'menu-' . $machine_name);
    $row_count = $query->execute()->rowCount();
    $this->assertEqual(count($this->hierarchy), $row_count);
  }

}

/**
 * Tests Taxonomy Menu configuration options.
 *
 * @TODO Add tests for other configuration options.
 */
class TaxonomyMenuConfigurationTest extends TaxonomyMenuWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Configuration options',
      'description' => 'Test configuration options.',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    // Create and login administrative user.
    $admin_user = $this->drupalCreateUser(array('administer taxonomy', 'administer menu'));
    $this->drupalLogin($admin_user);
    // Create a vocabulary.
    $this->vocabulary = $this->createVocabulary();
    // Create a hierarchy of taxonomy terms.
    $this->hierarchy = $this->createTermsHierarchy($this->vocabulary);
  }

  /**
   * Tests Taxonommy Menu sync option.
   */
  function testTaxonomyMenuSyncOption() {
    $vocab = $this->vocabulary->machine_name;

    // Set settings (no sync on main-menu).
    $edit = array(
      'taxonomy_menu[vocab_parent]' => 'main-menu:0',
      'taxonomy_menu[options][sync]' => FALSE,
    );
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertResponse(200);

    // Prepare changes.
    $new_name = $this->randomName(12);
    $test_term = $this->hierarchy[3]; // Arbitrary term from hierarchy
    $test_term->name = $new_name;

    // Save new term's name with sync option off.
    taxonomy_term_save($test_term);
    $mlid = _taxonomy_menu_get_mlid($test_term->tid, $this->vocabulary->vid);
    $menu_link = menu_link_load($mlid);
    $this->assertNotEqual($new_name, $menu_link['link_title']);

    // Switch to sync option on and save.
    $edit['taxonomy_menu[options][sync]'] = TRUE;
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertResponse(200);
    $mlid = _taxonomy_menu_get_mlid($test_term->tid, $this->vocabulary->vid);
    $menu_link = menu_link_load($mlid);
    $this->assertEqual($new_name, $menu_link['link_title']);
  }

}

/**
 * Tests for features requiring a taxonomy hierarchy
 */
class TaxonomyMenuHierarchyTest extends TaxonomyMenuWebTestCase {

  var $forest = array(
    "term1" => array(
      "term1_1" => TRUE,
      "term1_2" => array(
        "term1_2_1" => TRUE,
        "term1_2_2" => TRUE,
      ),
    ),
    "term2" => array(
      "term2_1" => TRUE,
      "term2_2" => TRUE,
    ),
    "term3" => TRUE
  );

  public static function getInfo() {
    return array(
      'name' => 'Hierarchy',
      'description' => 'Test functions related to taxonomy hierarchy',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'create article content', 'administer blocks', 'administer taxonomy', 'administer menu'));
    $this->drupalLogin($admin_user);
    $this->vocabulary = $this->createVocabulary();
    $this->terms = array();
    foreach ($this->forest as $name => $children) {
      $this->terms[] = new TaxonomyMenuTreeNode($this, NULL, $name, $children);
    }
  }


  function testTaxonomyMenuHierarchy() {
    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = 'navigation:0';
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');

    $this->assertResponse(200);

    // By default, auto expand is on : we must find the whole hierarchy
    foreach ($this->terms as $term)  {
      $this->assertLink($term->name); // 1st level
      foreach ($term->children as $child) {
        $this->assertLink($child->name); // 2nd level
        foreach ($child->children as $granchild) {
          $this->assertLink($granchild->name); // 3 level
          // No sub level.
        }
      }
    }

    // Set auto expand to off
    $edit = array();
    $edit['taxonomy_menu[options][expanded]'] = FALSE;
    //$edit['taxonomy_menu[options][rebuild]'] = '1'; // Rebuild menu on submit
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');
    $this->assertResponse(200);
    //$this->drupalGet('admin/structure/taxonomy/'.  $this->vocabulary->machine_name . '/edit');

    // We should have links to the first level of the hierarchy only
    $this->drupalGet('<front>');
    foreach ($this->terms as $term)  {
      $this->assertLink($term->name);
      foreach ($term->children as $child) {
        $this->assertNoLink($child->name);
      }
    }

    // Move to term1_2 : we should have links to
    // - 1st level
    // - siblings of term1_2
    // - children of term1_2
    $this->clickLink("term1");
    $this->clickLink("term1_2");

    foreach ($this->terms as $term)  {
      $this->assertLink($term->name); // 1st level
      foreach ($term->children as $child) {
        // second level
        if ($term->name != "term1") {
          $this->assertNoLink($child->name);
        }
        else {
          // We must have a link AND the children
          $this->assertLink($child->name);
          if ($child->name == "term1_2") {
            foreach ($child->children as $grandchild) {
              $this->assertLink($grandchild->name);
            }
          }
        }
      }
    }
  }
}

/**
 * Helper class to build the tree and keep data on hand
 */
class TaxonomyMenuTreeNode {
  function __construct(&$testcase, $parent, $name, $children) {
    $this->name = $name;
    $this->children = array();
    $this->parent = $parent;

    $this->term = $testcase->createNewTerm($testcase->vocabulary, $name, $parent ?$parent->term : NULL);

    taxonomy_term_save($this->term);
    if (is_array($children)) {
      foreach ($children as $name => $grandchildren) {
        $this->children[$name] = new TaxonomyMenuTreeNode($testcase, $this, $name, $grandchildren);
      }
    }
  }

  function display($level = "") {
    foreach ($this->children as $child) {
      $child->display($level . "  ");
    }
  }
}

