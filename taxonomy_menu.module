<?php

/**
 * @file
 * Generates menu links for all selected taxonomy terms.
 */

// Include the database layer.
module_load_include('inc', 'taxonomy_menu', 'taxonomy_menu.database');

// Include the batch functions.
module_load_include('inc', 'taxonomy_menu', 'taxonomy_menu.batch');


/**
 * Implements hook_help().
 */
function taxonomy_menu_help($path, $arg) {
  // @TODO Implement the hook. Make documentation available to the user.
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function taxonomy_menu_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  module_load_include('inc', 'taxonomy_menu', 'taxonomy_menu.admin');
  taxonomy_menu_form_taxonomy_form_vocabulary($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function taxonomy_menu_form_taxonomy_overview_terms_alter(&$form, &$form_state) {
  module_load_include('inc', 'taxonomy_menu', 'taxonomy_menu.admin');
  taxonomy_menu_form_taxonomy_overview_terms($form, $form_state);
}

/**
 * Rebuilds all the menu items.
 *
 * @param $vid
 *   The vocabulary ID of the taxonomy terms from which to rebuild the menu links.
 */
function _taxonomy_menu_rebuild($vid) {
  // Get the name of the menu from the administration settings.
  $menu_exists = taxonomy_menu_variable_get('vocab_menu', $vid, FALSE);
  // Delete the menu links associated to this vocabulary.
  _taxonomy_menu_delete_menu_links($vid);
  // Re-create the menu links if a menu is set.
  if ($menu_exists) {
    _taxonomy_menu_insert_menu_links($vid);
  }
}

/**
 * Inserts menu links associated to a vocabulary.
 *
 * @param $vid
 *   The ID of the vocabulary.
 */
function _taxonomy_menu_insert_menu_links($vid) {
  // Get the name of the menu from the administration settings.
  $menu_name = taxonomy_menu_variable_get('vocab_menu', $vid, FALSE);
  // Get a list of all the taxonomy terms for that vocabulary.
  $terms = taxonomy_get_tree($vid);
  // Let batch api take care of inserting the menu items.
  _taxonomy_menu_save_menu_links_batch($terms, $menu_name, 'creation');
  // Display a notification message.
  drupal_set_message(t('The Taxonomy menu has been created.'), 'status');
}

/**
 * Updates menu links associated to a vocabulary.
 *
 * @param $vid
 *   The ID of the vocabulary.
 */
function _taxonomy_menu_update_menu_links($vid) {
  // Get the name of the menu from the administration settings.
  $menu_name = taxonomy_menu_variable_get('vocab_menu', $vid, FALSE);
  // Get a list of all the terms to update.
  $tm_menu_links = _taxonomy_menu_get_menu_items($vid);
  $term_ids = array_values($tm_menu_links);
  $terms = taxonomy_term_load_multiple($term_ids);
  // Let batch api take care of inserting the menu items.
  _taxonomy_menu_save_menu_links_batch($terms, $menu_name);
  // Display a notification message.
  drupal_set_message(t('The Taxonomy menu has been updated.'), 'status');
}

/**
 * Deletes all the menu links associated to a vocabulary.
 *
 * @param $vid
 *   The vocabulary ID from which to delete the menu items.
 */
function _taxonomy_menu_delete_menu_links($vid) {
  $menu_items = _taxonomy_menu_get_menu_items($vid);
  $mlids = array_keys($menu_items);
  // Deletes all the menu items.
  foreach ($mlids as $mlid) {
    menu_link_delete($mlid);
  }
  // Delete all the database entries in {taxonomy_menu} table.
  _taxonomy_menu_delete_all($vid);
  // Display a notification message.
  drupal_set_message(t('The Taxonomy menu has been removed.'), 'status');
}

/**
 * Prepares a taxonomy item $item to be saved as a menu link.
 *
 * A menu item has the following properties:
 *  - link_path: (required)
 *  - link_title: (required)
 *  - menu_name: (optional)
 *  - weight: (optional)
 *  - expanded: (optional)
 *  - options: (optional)
 *  - mlid: (optional)
 *  - plid: (optional)
 *  - router_path:
 *
 * @param $term
 *   A taxonomy term used to save a respective menu item.
 * @param $menu_name
 *   The machine name of the menu in which the menu link should be saved.
 *
 * @return
 *   A menu link to be saved in the menu.
 *
 * @TODO Deal with paths validation.
 */
function _taxonomy_menu_prepare_menu_link($term, $menu_name) {
  static $weight = 0;
  $children_count = 0;
  $nodes_attached_count = 0;
  $langcode = isset($term->language) ? $term->language : LANGUAGE_NONE;

  // Options related to taxonomy menu and not the menu item in itself.
  $taxonomy_menu_options = array(
    'update' => TRUE,
  );

  // If a taxonomy term has already been saved as a menu item, load the menu
  // item. Else, we build it from scratch.
  $mlid = _taxonomy_menu_get_mlid($term->tid, $term->vid, $langcode);
  if ($mlid) {
    $menu_link = menu_link_load($mlid);
  }
  else {
    // Flag a menu item creation for later use.
    $taxonomy_menu_options['update'] = FALSE;
    $menu_link = array();

    // Only add/change a weight for newly created items. This is important for
    // menu links that have nodes as links.
    $menu_link['weight'] = $term->weight;
    $menu_link['hidden'] = 0;
  }

  // Menu name, language, module ownership
  $menu_link['module'] = 'taxonomy_menu';
  $menu_link['menu_name'] = $menu_name;
  $menu_link['language'] = $langcode;

  // Has children.
  $children = taxonomy_get_children($term->tid, $term->vid);
  if (!empty($children)) {
    $menu_link['has_children'] = 1;
    $children_count = count($children);
  }

  // Expanded.
  $menu_link['expanded'] = taxonomy_menu_variable_get('expanded', $term->vid, 0);

  // Flatten.
  $flatten_menu = taxonomy_menu_variable_get('flat', $term->vid, 0);
  if ($flatten_menu) {
    $menu_link['weight'] = $weight++;
    $menu_link['has_children'] = 0;
    $menu_link['plid'] = taxonomy_menu_variable_get('vocab_parent', $term->vid, NULL);
    $menu_link['expanded'] = 0;
  }

  // Empty terms.
  // Hide all terms that are not associated to a node.
  $hide_empty_terms = taxonomy_menu_variable_get('hide_empty_terms', $term->vid, FALSE);
  if ($hide_empty_terms) {
    $result = taxonomy_menu_term_count_nodes($term->tid, $term->vid);
    $menu_link['hidden'] = ($result == 0) ? 1 : 0;
  }

  // Title.
  // Append the number of children per taxonomy terms to the menu link's title
  // if selected, else give it the name of the taxonomy term.
  $menu_link['link_title'] = $term->name;
  $display_number = taxonomy_menu_variable_get('display_num', $term->vid, FALSE);
  if ($display_number && !$flatten_menu && $children_count != 0) {
    $node_count = taxonomy_menu_term_count_nodes($term->tid, $term->vid);
    $menu_link['link_title'] .= " (" . $children_count . ")";
  }

  // HTML Title attribute.
  $display_title_att = taxonomy_menu_variable_get('display_title_attr', $term->vid, TRUE);
  if ($display_title_att) {
    $term_description = taxonomy_menu_variable_get('term_item_description', $term->vid, 0);
    $menu_link['options']['attributes']['title'] = $term_description ? $term->description : '';
  }
  else {
    $menu_link['options']['attributes']['title'] = '';
  }

  // Path.
  // Create the path of the menu item and normalize it.
  $link_path = taxonomy_menu_create_path($term->vid, $term->tid);
  $menu_link['link_path'] = drupal_get_normal_path($link_path, $langcode);

  // Set the mlid of its parent. Flatten option has already been processed.
  if (!$flatten_menu) {
    $menu_link['plid'] = _taxonomy_menu_determine_plid($term, $langcode);
  }

  // Set the taxonomy menu options.
  $menu_link['taxonomy_menu'] = $taxonomy_menu_options;

  return $menu_link;
}

/**
 * Helper function to check if a taxonomy term is empty.
 *
 * A taxonomy term is empty if there is no nodes attached to it. For now, the
 * function is not recursive.
 *
 * @param $term
 *   The taxonomy term to be checked.
 *
 * @TODO Make the function recursive if necessary.
 */
function _taxonomy_menu_is_term_empty($term) {
  $nodes = taxonomy_select_nodes($term);
  $is_term_empty = empty($nodes);

  return $is_term_empty;
}

/**
 * Helper function to determine a parent mlid for a specific taxonomy term, in
 * function of the settings of the administration pages.
 *
 * @param $term
 *   The term, which we want to find the parent mlid.
 * @param $langcode
 *   The language of the term.
 *
 * @return $plid
 *   The corresponding parent mlid.
 */
function _taxonomy_menu_determine_plid($term, $langcode) {
  $plid = 0;
  $parents = taxonomy_get_parents($term->tid);
  if (empty($parents)) {
    // Try to get the vocabulary parent from the settings
    // Returns for example:
    //  - "0:0" : DISABLED
    //  - "main-menu:0" : MENU ROOT
    //  - "main-menu:123" : MENU ITEM ROOT
    $vocab_parent = taxonomy_menu_variable_get('vocab_parent', $term->vid, NULL);
    if ($vocab_parent) {
      // "main-menu:123" case
      $plid = $vocab_parent;
    }
    else {
      // "main-menu:0" OR "0:0" cases
      $plid = 0;
    }
  }
  else {
    // We have parents for this taxonomy term. Only get the first one, we don't
    // support multiple parents yet.
    // @TODO Support multiple parents.
    foreach ($parents as $parent) {
      $plid = _taxonomy_menu_get_mlid($parent->tid, $term->vid, $langcode);
      break;
    }
    if ($plid == FALSE) {
      $plid = 0;
    }
  }

  return $plid;
}

/**
 * Saves a menu link in a menu, based on a taxonomy term.
 *
 * @param $term
 *   A taxonomy term used to save a respective menu item.
 * @param $menu_name
 *   The machine name of the menu in which the menu link should be saved.
 *
 * @return
 *   The menu link ID of the menu item that has been saved. FALSE, if no item
 *   could be saved.
 */
function taxonomy_menu_save_menu_link($term, $menu_name) {
  $hook = 'taxonomy_menu';

  // Prepare a menu link based on the settings of the vocabulary edit page.
  $menu_link = _taxonomy_menu_prepare_menu_link($term, $menu_name);

  // Save the resulting menu item.
  $mlid = menu_link_save($menu_link);

  // Let other modules perform actions after the menu item has been saved.
  foreach (module_implements($hook . '_save') as $module) {
    $function = $module . '_' . $hook . '_save';
    $function($term, $menu_link, $mlid);
  }

  return $mlid;
}

/**
 * Implements hook_taxonomy_menu_save().
 *
 * Updates {taxonomy_menu} table using the newly created menu item.
 */
function taxonomy_menu_taxonomy_menu_save($term, $menu_link, $mlid) {
  if ($menu_link['taxonomy_menu']['update'] == FALSE) {
    _taxonomy_menu_insert_menu_item($mlid, $term->tid, $term->vid, $menu_link['language']);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 */
function taxonomy_menu_taxonomy_vocabulary_delete($vocabulary) {
  // When a vocabulary is deleted, remove all the menu items associated with it
  // and rebuild the menu they were inserted into.
  _taxonomy_menu_delete_menu_links($vocabulary->vid);
}

/**
 * Implements hook_taxonomy_term_insert($term).
 */

function taxonomy_menu_taxonomy_term_insert($term) {
  _taxonomy_menu_termapi_helper($term, 'insert');
}

/**
 * Implements hook_taxonomy_term_update().
 */

function taxonomy_menu_taxonomy_term_update($term) {
  _taxonomy_menu_termapi_helper($term, 'update');
}

/**
 * Implements hook_taxonomy_term_delete().
 */

function taxonomy_menu_taxonomy_term_delete($term) {
  _taxonomy_menu_termapi_helper($term, 'delete');
}

/**
 * Implements hook_node_insert().
 *
 * @TODO Update the menu items count, empty terms.
 */
function taxonomy_menu_node_insert($node) {
}

/**
 * Implements hook_node_update().
 *
 * @TODO Update the menu items count, empty terms.
 */
function taxonomy_menu_node_update($node) {
}

/**
 * Implements hook_node_presave().
 *
 * @TODO Update the menu items count, empty terms.
 */
function taxonomy_menu_node_presave($node) {
}

/**
 * Implements hook_node_delete().
 *
 * @TODO Update the menu items count, empty terms.
 */
function taxonomy_menu_node_delete($node) {
}

/**
 * Abstraction of hook_node_<op>().
 *
 * @param $node
 *   The node to process.
 * @param $operation
 *   A string of the operation to be performed [update|insert|delete].
 *
 * @TODO Rebuild the function.
 */
function _taxonomy_menu_nodeapi_helper($node, $operation) {
  $terms = array();

  // Update the taxonomy menu for each terms
  foreach ($terms as $key => $tid) {
    $menu_name = taxonomy_menu_variable_get('vocab_menu', $term->vid, FALSE);
    $sync = taxonomy_menu_variable_get('sync', $term->vid, TRUE);
    $display_num = taxonomy_menu_variable_get('display_num', $term->vid, TRUE);
    $hide_empty_terms = taxonomy_menu_variable_get('hide_empty_terms', $term->vid, FALSE);
    $term = taxonomy_term_load($tid);
    if ($term  && $menu_name && $sync && ($display_num || $hide_empty)) {
      switch ($operation) {
        case 'insert':
          break;
        case 'update':
          if ($hide_empty_terms) {
            _taxonomy_menu_update_all_parents($term, $menu_name);
          }
          break;
        case 'delete':
          break;
      }
    }
    // Report status.
    //drupal_set_message($message, 'status');
    // Rebuild the menu.
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Abstraction of hook_termapi_<op>().
 *
 * @param $term
 *   The term to process.
 * @param $operation
 *   A string of the operation to be performed [update|insert|delete].
 */
function _taxonomy_menu_termapi_helper($term, $operation) {
  // Only sync if taxonomy_menu is enabled for this vocab and the 'sync'
  // option has been checked.
  $menu_name = taxonomy_menu_variable_get('vocab_menu', $term->vid, 0);
  $sync = taxonomy_menu_variable_get('sync', $term->vid, 0);
  if ($menu_name && $sync) {
    switch ($operation) {
      case 'insert':
        $text = 'Added term %term to taxonomy menu %menu_name.';
        break;
      case 'update':
        $text = 'Updated term %term in taxonomy menu %menu_name.';
        break;
      case 'delete':
        $text = 'Deleted term %term from taxonomy menu %menu_name.';
        break;
    }
    $message = t($text, array('%term' => $term->name, '%menu_name' => $menu_name));
    // Delete the association in the {taxonomy_menu} table, else save the menu link.
    if ($operation == 'delete') {
      $mlid = _taxonomy_menu_get_mlid($term->tid, $term->vid);
      _taxonomy_menu_delete_item($term->vid, $term->tid);
      menu_link_delete($mlid);
    }
    else {
      taxonomy_menu_save_menu_link($term, $menu_name);
    }
    // Report status.
    drupal_set_message($message, 'status');
    // Rebuild the menu.
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Update all parent items.
 *
 * @param $term
 *   The taxonomy term from which to update the parents.
 * @param $menu_name
 *   The menu name of the resulting menu links.
 */
function _taxonomy_menu_update_all_parents($term, $menu_name) {
  $parents = taxonomy_get_parents($term->tid);
  if ($parents) {
    // Let batch api take care of updating the menu items.
    _taxonomy_menu_save_menu_links_batch($parents, $menu_name);
  }
}

/**
 * Helper function to see if any of the children have any nodes.
 *
 * @param $tid
 * @param $vid
 *
 * @return boolean
 */
function _taxonomy_menu_children_has_nodes($tid, $vid, $return = FALSE) {
  $children = taxonomy_get_children($tid, $vid);
  foreach ($children as $tid => $term) {
    if (_taxonomy_menu_term_count($tid) > 0) {
      $return = TRUE;
    }
    else {
      $return = _taxonomy_menu_children_has_nodes($tid, $vid, $return);
    }
  }
  return $return;
}

/**
 * Calculates the number of nodes linked to a term. It can be either recursive
 * and process all the children or just for this very term.
 *
 * @param $tid
 *   The term ID.
 * @param $vid
 *   The vocabulary ID.
 * @param $count
 *   The current node count.
 * @param $recursive
 *   Process all the children or not. Default is TRUE.
 *
 * @return int
 *   The number of nodes attached to a term and optionally its children.
 *
 * @TODO Rewrite the function so that we don't have this code duplicates at the
 * end.
 */
function taxonomy_menu_term_count_nodes($tid, $vid, $count = 0, $recursive = TRUE) {
  // Case of a vocabulary item. No nodes can be attached to this "false" taxonomy term.
  if ($tid == 0) {
    return FALSE;
  }

  if ($recursive) {
    $children = taxonomy_get_children($tid, $vid);
    if (!empty($children)) {
      $associated_nodes = taxonomy_select_nodes($tid);
      $current_count = empty($associated_nodes) ? 0 : count($associated_nodes);
      foreach ($children as $term) {
        $count += taxonomy_menu_term_count_nodes($term->tid, $term->vid, $current_count);
      }
    }
    else {
      $associated_nodes = taxonomy_select_nodes($tid);
      $count += !empty($associated_nodes) ? count($associated_nodes) : 0;
    }
  }
  else {
    $associated_nodes = taxonomy_select_nodes($tid);
    $count = !empty($associated_nodes) ? count($associated_nodes) : 0;
  }

  return $count;
}

/**
 * Implements hook_taxonomy_menu_path().
 *
 * Invoked from _taxonomy_menu_get_paths.
 *
 * @return array
 *   function name => Display Title
 *   a list of the path options.
 */
function taxonomy_menu_taxonomy_menu_path() {
  $output = array(
    'taxonomy_menu_path_default' => t('Default'),
  );

  return $output;
}

/**
 * Callback for hook_taxonomy_menu_path.
 */
function taxonomy_menu_path_default($vid, $tid) {
  // If tid = 0 then we are creating the vocab menu item format will be
  // taxonomy/term/$tid+$tid+$tid+....
  if ($tid == 0) {
    // Get all of the terms for the vocab.
    $vtids = _taxonomy_menu_get_terms($vid);
    $end = implode(' ', $vtids);
    $path = "taxonomy/term/$end";
  }
  else {
    $path = 'taxonomy/term/' . $tid;
    if (taxonomy_menu_variable_get('display_decendants', $vid, FALSE)) {
      // Use 'all' at the end of the path
      if (taxonomy_menu_variable_get('end_all', $vid, FALSE)) {
        $path .= '/all';
      }
      else {
        // We wait to run this instead of during the if above because we only
        // want to run it once.
        $terms = taxonomy_get_tree($vid, $tid);
        foreach ($terms as $term) {
          $tids[] = $term->tid;
        }
        if ($tids) {
          $end = implode(' ', $tids);
          $path .= ' ' . $end;
        }
      }
    }
  }

  return $path;
}

/**
 * Creates the path to use in a menu item.
 *
 * @return array
 *   An array of paths' selections.
 */
function _taxonomy_menu_get_paths() {
  return module_invoke_all('taxonomy_menu_path');
}

/**
 * Creates the path for the vid/tid combination.
 *
 * @param $vid
 * @param $tid
 *
 * @return string
 */
function taxonomy_menu_create_path($vid, $tid) {
  // Get the path function for this vocabulary.
  $function = taxonomy_menu_variable_get('path', $vid, 'taxonomy_menu_path_default');
  // Run the function.
  return $function($vid, $tid);
}

/**
 * Implements hook_translated_menu_link_alter().
 *
 * Translate menu links on the fly by using term translations.
 */
function taxonomy_menu_translated_menu_link_alter(&$item, $map) {
  if (module_exists('i18n_taxonomy')) {
    // In case of localized terms, use term translation for menu title.
    if ($item['module'] == 'taxonomy_menu') {
      $t = _taxonomy_menu_get_item($item['mlid']);
      // Only translate when term exist (may per example occur with stray menu item)
      if ($t) {
        // Only translate when translation mode is set to localize
        if (i18n_taxonomy_vocabulary_mode($t->vid, I18N_MODE_LOCALIZE)) {
          // this is a term
          if ($t->tid > 0) {
            $term = taxonomy_term_load($t->tid);
            $display_num = '';
            $num = _taxonomy_menu_term_count($t->tid);

            // If hide menu is selected and the term count is 0 and the term has no children then do not create the menu item
            if ($num == 0 && taxonomy_menu_variable_get('hide_empty_terms', $t->vid, FALSE) && !_taxonomy_menu_children_has_nodes($t->tid, $t->vid)) {
              $display_num = '';
            }
            // if display number is selected and $num > 0 then change the title
            elseif (taxonomy_menu_variable_get('display_num', $t->vid, FALSE)) {
              // if number > 0 and display decendants, then count all of the children
              if (taxonomy_menu_variable_get('display_descendants', $t->vid, FALSE)) {
                $num = taxonomy_menu_term_count_nodes($t->tid, $t->vid);
              }
              $display_num = " ($num)";
            }

            if ($item['title'] != ($term->name . $display_num)) {
              // Should not happen
              watchdog('error', 'Menu and taxonomy name mismatch: @title != @name', array('@title' => $item['title'], '@name' => $term->name . $display_num));
            }

            $term = i18n_taxonomy_localize_terms($term);
            $item['title'] = $item['link_title'] = $term->name . $display_num;
            if ($term->description) {
              $item['options']['attributes']['title'] = $term->description;
            }
          }
          // is a vocabulary
          else {
            $vocab = taxonomy_vocabulary_load($t->vid);
            $item['title'] = i18n_string('taxonomy:vocabulary:' . $vocab->vid . ':name', $vocab->name);
          }
        }
      }
      // no term, add a watchdog entry to help
      else {
        watchdog('taxonomy_menu', 'Error with menu entry "%me" in menu "%mt"', array('%me' => $item['title'], '%mt' => $item['menu_name']));
      }
    }
  }
}

/**
 * Builds a variable from the supplied name and machine name of the vocabulary.
 *
 * @param $name
 *   String to be added to the returned variable.
 * @param $vid
 *   vid of the vocabulary from which the machine name will be taken.
 *
 * @return bool|string
 */
function _taxonomy_menu_build_variable($name, $vid) {
  $vocabulary = taxonomy_vocabulary_load($vid);
  if ($vocabulary) {
    return 'taxonomy_menu_' . $name . '_' . $vocabulary->machine_name;
  }
  else {
    return FALSE;
  }
}

/**
 * Helper function to replace Drupal's variable_get() for Taxonomy menu.
 * Gets a value per vocabulary.
 */
function taxonomy_menu_variable_get($key, $vid, $default) {
  return variable_get(_taxonomy_menu_build_variable($key, $vid), $default);
}

/**
 * Helper function to replace Drupal's variable_set() for Taxonomy menu.
 * Sets a value per vocabulary.
 */
function taxonomy_menu_variable_set($key, $vid, $value) {
  return variable_set(_taxonomy_menu_build_variable($key, $vid), $value);
}

