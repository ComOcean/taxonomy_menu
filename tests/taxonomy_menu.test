<?php

/**
 * @file
 * Tests for taxonomy_menu.module.
 */

/**
 * Provides common helper methods for Taxonomy Menu module tests.
 */
class TaxonomyMenuWebTestCase extends TaxonomyWebTestCase {

  /**
   * Creates a hierarchy of taxonomy terms for the vocabulary defined in the
   * current class. The hierarchy is as follow:
   *
   * terms[1]         | depth: 0
   * -- terms[2]      | depth: 1
   * -- terms[3]      | depth: 1
   * ---- terms[4]    | depth: 2
   * -- terms[5]      | depth: 1
   * terms[6]         | depth: 0
   * -- terms[7]      | depth: 1
   *
   * @TODO Add multiple parents when taxonomy_menu can deal with it.
   */
  function createTermsHierarchy() {
    $terms = array();

    // Create taxonomy terms.
    $vocabulary = $this->createVocabulary();
    for ($i = 1; $i < 8; $i++) {
      $terms[$i] = $this->createTerm($vocabulary);
    }

    // Set the hierarchy.
    $terms[2]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[2]);
    $terms[3]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[3]);
    $terms[4]->parent = array($terms[3]->tid);
    taxonomy_term_save($terms[4]);
    $terms[5]->parent = array($terms[1]->tid);
    taxonomy_term_save($terms[5]);
    $terms[7]->parent = array($terms[6]->tid);
    taxonomy_term_save($terms[7]);

    return $terms;
  }

  /**
   * Create a new term record
   */
  function createNewTerm($vocabulary, $name = NULL, $parent = NULL) {
    $term = new stdClass();
    $term->name = ($name === NULL) ? $this->randomName() : $name;
    $term->description = $this->randomName();
    $term->format = db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocabulary->vid;
    if ($parent !== NULL) {
      $term->parent = array($parent->tid);
    }

    return $term;
  }
}

/**
 * Tests the taxonomy vocabulary interface.
 */
class TaxonomyMenuFunctionalTest extends TaxonomyMenuWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Vocabulary interface',
      'description' => 'Test the taxonomy menu vocabulary interface.',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    // Create and login administrative user.
    $admin_user = $this->drupalCreateUser(array('administer taxonomy', 'administer menu'));
    $this->drupalLogin($admin_user);
    // Create a vocabulary.
    $this->vocabulary = $this->createVocabulary();
    // Create a hierarchy of taxonomy terms.
    $this->hierarchy = $this->createTermsHierarchy();
  }

  /**
   * Saves a taxonomy vocabulary via the user interface.
   */
  function testTaxonomyMenuVocabularyInterface() {
    $menu_name = 'user-menu';
    $vocab = $this->vocabulary->machine_name;

    // Visit the main taxonomy administration page.
    $this->drupalGet('admin/structure/taxonomy/' . $vocab . '/edit');

    // Options for the taxonomy vocabulary edit form.
    $edit = array();

    // Try to submit a vocabulary when menu location is a root menu item.
    $edit['taxonomy_menu[vocab_parent]'] = $menu_name . ':0';
    $this->drupalPost(NULL, $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been updated.'));

    // Try to submit a vocabulary removing the menu location.
    $edit['taxonomy_menu[vocab_parent]'] = '0';
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been removed.'));

    // Try to submit a vocabulary when menu location is a menu item.
    $edit['taxonomy_menu[vocab_parent]'] = $menu_name . ':2';
    $this->drupalPost('admin/structure/taxonomy/' . $vocab . '/edit', $edit, t('Save'));
    $this->assertRaw(t('The Taxonomy Menu has been updated.'));
  }

}

/**
 * Tests for taxonomy vocabulary functions.
 */
class TaxonomyMenuUnitTest extends TaxonomyMenuWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'CRUD',
      'description' => 'Test CRUD functions',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'administer blocks', 'administer taxonomy', 'administer menu', 'administer nodes', 'create article content', 'create page content', 'edit any article content', 'edit any page content', 'delete any article content', 'delete any page content', 'access content overview'));
    $this->drupalLogin($admin_user);
    $this->vocabulary = $this->createVocabulary();
    $this->term = $this->createTerm($this->vocabulary);
  }

  function testTaxonomyMenuCRUD() {
    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = 'main-menu:0';
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');

    $this->assertResponse(200);

    $term = $this->term;
    $this->assertLink($term->name);

    $term = $this->term;
    taxonomy_term_delete($term->tid);
    $this->drupalGet('<front>');

    $this->assertNoLink($term->name);

    $node = $this->drupalCreateNode();
    $this->drupalPost("node/$node->nid/delete", array(), t('Delete'));
    $this->drupalGet("node/$node->nid");
    $this->assertResponse(404);

  }

  function testTaxonomyMenuCustomMenu() {
    // Create a custom menu.
    $edit = array();
    $custom_name = $this->randomName(16);
    $machine_name = drupal_substr(hash('sha256', $custom_name), 0, MENU_MAX_MENU_NAME_LENGTH_UI);
    $edit['title'] = $custom_name;
    $edit['menu_name'] = $machine_name;
    $this->drupalPost('admin/structure/menu/add', $edit, 'Save');

    // Move the menu block to a region.
    $edit = array();
    $edit['blocks[menu_menu-' . $machine_name . '][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, 'Save blocks');
    $this->assertResponse(200);

    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = 'menu-' . $machine_name . ':0';
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');

    $term = $this->term;
    $this->drupalGet('<front>');
    $this->assertLink($term->name);

    $term = $this->term;
    taxonomy_term_delete($term->tid);
    $this->drupalGet('<front>');

    $this->assertNoLink($term->name);
  }
}

/**
 * Tests for features requiring a taxonomy hierarchy
 */
class TaxonomyMenuHierarchyTest extends TaxonomyMenuWebTestCase {

  var $forest = array(
    "term1" => array(
      "term1_1" => TRUE,
      "term1_2" => array(
        "term1_2_1" => TRUE,
        "term1_2_2" => TRUE,
      ),
    ),
    "term2" => array(
      "term2_1" => TRUE,
      "term2_2" => TRUE,
    ),
    "term3" => TRUE
  );

  public static function getInfo() {
    return array(
      'name' => 'Hierarchy',
      'description' => 'Test functions related to taxonomy hierarchy',
      'group' => 'Taxonomy menu',
    );
  }

  function setUp() {
    parent::setUp('taxonomy_menu');
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'create article content', 'administer blocks', 'administer taxonomy', 'administer menu'));
    $this->drupalLogin($admin_user);
    $this->vocabulary = $this->createVocabulary();
    $this->terms = array();
    foreach ($this->forest as $name => $children) {
      $this->terms[] = new TaxonomyMenuTreeNode($this, NULL, $name, $children);
    }
  }


  function testTaxonomyMenuHierarchy() {
    $edit = array();
    $edit['taxonomy_menu[vocab_parent]'] = 'navigation:0';
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');

    $this->assertResponse(200);

    // By default, auto expand is on : we must find the whole hierarchy
    foreach ($this->terms as $term)  {
      $this->assertLink($term->name); // 1st level
      foreach ($term->children as $child) {
        $this->assertLink($child->name); // 2nd level
        foreach ($child->children as $granchild) {
          $this->assertLink($granchild->name); // 3 level
          // No sub level.
        }
      }
    }

    // Set auto expand to off
    $edit = array();
    $edit['taxonomy_menu[options][expanded]'] = FALSE;
    //$edit['taxonomy_menu[options][rebuild]'] = '1'; // Rebuild menu on submit
    $this->drupalPost('admin/structure/taxonomy/' . $this->vocabulary->machine_name . '/edit', $edit, 'Save');
    $this->assertResponse(200);
    //$this->drupalGet('admin/structure/taxonomy/'.  $this->vocabulary->machine_name . '/edit');

    // We should have links to the first level of the hierarchy only
    $this->drupalGet('<front>');
    foreach ($this->terms as $term)  {
      $this->assertLink($term->name);
      foreach ($term->children as $child) {
        $this->assertNoLink($child->name);
      }
    }

    // Move to term1_2 : we should have links to
    // - 1st level
    // - siblings of term1_2
    // - children of term1_2
    $this->clickLink("term1");
    $this->clickLink("term1_2");

    foreach ($this->terms as $term)  {
      $this->assertLink($term->name); // 1st level
      foreach ($term->children as $child) {
        // second level
        if ($term->name != "term1") {
          $this->assertNoLink($child->name);
        }
        else {
          // We must have a link AND the children
          $this->assertLink($child->name);
          if ($child->name == "term1_2") {
            foreach ($child->children as $grandchild) {
              $this->assertLink($grandchild->name);
            }
          }
        }
      }
    }
  }
}

/**
 * Helper class to build the tree and keep data on hand
 */
class TaxonomyMenuTreeNode {
  function __construct(&$testcase, $parent, $name, $children) {
    $this->name = $name;
    $this->children = array();
    $this->parent = $parent;

    $this->term = $testcase->createNewTerm($testcase->vocabulary, $name, $parent ?$parent->term : NULL);

    taxonomy_term_save($this->term);
    if (is_array($children)) {
      foreach ($children as $name => $grandchildren) {
        $this->children[$name] = new TaxonomyMenuTreeNode($testcase, $this, $name, $grandchildren);
      }
    }
  }

  function display($level = "") {
    foreach ($this->children as $child) {
      $child->display($level . "  ");
    }
  }
}

